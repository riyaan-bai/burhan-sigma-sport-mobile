# PERTANYAAN

## Tugas 7

1. Jelaskan apa itu widget tree pada Flutter dan bagaimana hubungan parent-child (induk-anak) bekerja antar widget?

-> Widget tree adalah cara Flutter menyusun seluruh antarmuka pengguna (UI) ke dalam sebuah struktur hierarki. Hal ini dapat diibaratkan seperti pohon silsilah dimana setiap widget ialah anggota keluarga dengan satu widget root di paling atas. Nantinya, di dalam pohon ini akan tercipta hubungan parent-child dengan parent adalah widget yang berisi widget lain dan child adalah widget yang ada di dalamnya. Parent bertanggung jawab untuk mengonfigurasi dan menentukan posisi child-nya sementara child menerima konfigurasi tersebut dan membangun dirinya sendiri. Seluruh tata letak, data, dan state akan diimplementasikan dari atas ke bawah (dari parent ke child) melalui pohon ini.

2. Sebutkan semua widget yang kamu gunakan dalam proyek ini dan jelaskan fungsinya!

-> Dalam proyek ini, saya menggunakan MyHomePage dan Scaffold yang menyediakan struktur dasar dengan AppBar di atas. Untuk layout, saya memakai Column untuk menyusun vertikal, Row untuk menyusun horizontal, Padding untuk memberi jarak, SizedBox untuk memberi spasi, Center untuk memberikan posisi tengah, dan GridView untuk menggunakan material. Saya juga menggunakan widget kustom InfoCard dan ItemCard untuk menampilkan data, text untuk menampilkan semua teks, Image.asset untuk gambar, dan Container untuk membungkus elemen di dalam InfoCard dan ItemCard. Terakhir, saya juga menggunakan ScaffoldMessenger untuk menampilkan SnackBar saat item diklik.

3. Apa fungsi dari widget MaterialApp? Jelaskan mengapa widget ini sering digunakan sebagai widget root!

-> MaterialApp adalah widget pembungkus utama yang mengonfigurasi aplikasi agar menggunakan standar material design dari Google. Fungsinya adalah menyediakan banyak fitur level aplikasi, seperti sistem navigasi untuk berpindah halaman, pengaturan tema global, dan lokalisasi. Widget ini sering digunakan sebagai root karena menyediakan layanan yang diperlukan oleh hampir semua widget material design lainnya. Tanpa MaterialApp, maka akan banyak widget umum yang tidak berfungsi dengan benar.

4. Jelaskan perbedaan antara StatelessWidget dan StatefulWidget. Kapan kamu memilih salah satunya?

-> StatelessWidget bersifat immutable yan berimplikasi pada properti dan tampilannya yang tidak dapat berubah setelah widget dibuat. Contohnya adalah Icon, Text, atau ItemCard dimana semua data diterima dari parent dan tidak pernah berubah secara internal. Sementara itu, StatefulWidget bersifat mutable dan dapat berubah selama aplikasi berjalan karena memiliki objek State terpisah yang dapat menyimpan data dan memicu rebuild saat data tersebut berubah. StatelessWidget dapat dipilih untuk UI yang statis sedangkan StatefulWidget dipilih ketika memerlukan pengelolaan data yang berubah secara internal, seperti input pengguna pada TextField atau data yang dimuat dari internet.

5. Apa itu BuildContext dan mengapa penting di Flutter? Bagaimana penggunaannya di metode build?

-> BuildContext adalah alamat unik sebuah widget di dalam widget tree. Hal ini penting karena BuildContext adalah handle yang digunakan untuk menemukan dan berinteraksi dengan widget parent di dalam tree. Di metode build, BuildContext adalah cara mengakses layanan yang disediakan oleh parent, seperti menggunakan Theme.of(context) atau Navigator untuk berpindah halaman. Di dalam kode saya, hal ini digunakan dalam ScaffoldMessenger.of(context) untuk menemukan ScaffoldMessenger terdekat dan menampilkan SnackBar.

6. Jelaskan konsep "hot reload" di Flutter dan bagaimana bedanya dengan "hot restart"!

-> Hot Reload adalah kondisi dimana Flutter menyuntikkan file kode yang telah diubah ke dalam Dart Virtual Machine yang sedang berjalan sehingga state aplikasi saat ini tetap terjaga tanpa me-restart aplikasi dan memungkinkan melihat perubahan UI secara instan. Sebaliknya, Hot Restart akan menghancurkan Dart VM yang ada dan membuat yang baru sehingga akan memulai ulang seluruh aplikasi dari awal. Hot Restart juga akan mengatur ulang semua state aplikasi kembali ke kondisi awal seolah-olah baru ditutup dan membuka kembali aplikasi tersebut.

## Tugas 8

1. Jelaskan perbedaan antara Navigator.push() dan Navigator.pushReplacement() pada Flutter. Dalam kasus apa sebaiknya masing-masing digunakan pada aplikasi Football Shop kamu?

-> Navigator.push() berfungsi untuk menambahkan halaman baru di atas tumpukan navigasi sehingga halaman lama masih ada di bawahnya dan pengguna bisa menekan tombol "kembali". Sebaliknya, Navigator.pushReplacement() berfungsi untuk mengganti halaman saat ini dengan halaman baru sehingga halaman sebelumnya dihapus dari tumpukan dan pengguna tidak bisa kembali. Pada aplikasi saya, push() digunakan saat menekan tombol "Create Product" untuk membuka formulir sehingga pengguna bisa kembali ke halaman utama. Sedangkan pushReplacement() digunakan saat menekan "Halaman Utama" dari drawer untuk mencegah halaman utama menumpuk di atas dirinya sendiri.

2. Bagaimana kamu memanfaatkan hierarchy widget seperti Scaffold, AppBar, dan Drawer untuk membangun struktur halaman yang konsisten di seluruh aplikasi?

-> Saya memanfaatkan hirarki widget dengan Scaffold yang digunakan sebagai kerangka dasar untuk setiap halaman yang menyediakan slot standar untuk elemen umum seperti appBar, body, dan drawer sehingga semua halaman memiliki struktur dasar yang sama. Kemudian, AppBar ditempatkan di dalam slot appBar milik Scaffold dengan properti yang konsisten di setiap halaman. Terakhir, Drawer ditempatkan ke dalam slot drawer milik Scaffold dengan satu file agar navigasi selalu identik dan mudah ditemukan.

3.  Dalam konteks desain antarmuka, apa kelebihan menggunakan layout widget seperti Padding, SingleChildScrollView, dan ListView saat menampilkan elemen-elemen form? Berikan contoh penggunaannya dari aplikasi kamu.

-> Kelebihan utama layout widget adalah menciptakan antarmuka formulir yang rapi, responsif, dan mudah digunakan. Padding digunakan untuk memberi space antar elemen input seperti TextFormField agar tidak menempel di tepi layar. SingleChildScrollView digunakan untuk membungkus seluruh Form serta memastikan semua field tetap bisa diisi dan di-scroll bahkan saat keyboard virtual muncul di layar kecil. ListView berfungsi menyusun semua elemen input dan tombol secara vertikal dengan teratur.

4.Bagaimana kamu menyesuaikan warna tema agar aplikasi Football Shop memiliki identitas visual yang konsisten dengan brand toko?

-> Penyesuaian warna tema dilakukan secara terpusat di dalam widget MaterialApp pada berkas main.dart. Di dalam properti theme ThemeData diatur dan colorScheme juga didefinisikan. Untuk aplikasi saya, saya menggunakan ColorScheme.fromSwatch(primarySwatch: Colors.blue) yang menetapkan warna biru khas aplikasi sebagai warna primer. Warna ini kemudian secara otomatis digunakan oleh widget lain seperti AppBar dan DrawerHeader, sehingga menciptakan identitas visual yang konsisten.

## Tugas 9
1. Jelaskan mengapa kita perlu membuat model Dart saat mengambil/mengirim data JSON? Apa konsekuensinya jika langsung memetakan Map<String, dynamic> tanpa model (terkait validasi tipe, null-safety, maintainability)?
-> Model Dart dibuat untuk menjamin keamanan tipe (type safety) dan struktur data yang jelas sehingga kesalahan dapat dideteksi oleh compiler saat penulisan kode. Tanpa model, penggunaan Map<String, dynamic> membuat validasi tipe dan null-safety tidak berjalan otomatis dan daapt meningkatkan risiko crash akibat akses data yang salah atau bernilai null. Selain itu, maintainability kode akan buruk karena kita harus mengetik key berupa string secara manual yang rentan typo. Akibatnya, kode menjadi sulit dibaca dan susah di-refactor dibandingkan dengan menggunakan objek model yang terstruktur.

2. Apa fungsi package http dan CookieRequest dalam tugas ini? Jelaskan perbedaan peran http vs CookieRequest.
-> Package http berfungsi untuk melakukan permintaan jaringan yang bersifat stateless, sedangkan CookieRequest adalah modul khusus yang dirancang untuk mengelola cookies dan menjaga sesi login pengguna secara otomatis. Perbedaan utamanya adalah http menganggap setiap permintaan sebagai koneksi baru, sedangkan CookieRequest menyertakan cookie sesi di setiap permintaan sehingga server dapat mengenali pengguna yang sudah login. Dalam tugas ini, CookieRequest digunakan untuk mengakses fitur-fitur terproteksi seperti logout atau melihat data spesifik pengguna. Tanpa CookieRequest, aplikasi tidak akan bisa mempertahankan status login pengguna saat berpindah-pindah halaman.

3. Jelaskan mengapa instance CookieRequest perlu untuk dibagikan ke semua komponen di aplikasi Flutter.
-> Instance CookieRequest perlu dibagikan ke semua komponen aplikasi untuk menjaga konsistensi data sesi dan cookies pengguna di seluruh layar. Karena CookieRequest menyimpan status login, jika setiap komponen membuat instance baru maka data sesi tersebut akan hilang dan server akan menganggap pengguna belum terautentikasi. Dengan membagikan satu instance yang sama, semua permintaan HTTP dari halaman mana pun akan menyertakan cookies sesi yang valid. Hal ini memastikan status login tetap terjaga saat berpindah-pindah halaman tanpa perlu melakukan login ulang.

4. Jelaskan konfigurasi konektivitas yang diperlukan agar Flutter dapat berkomunikasi dengan Django. Mengapa kita perlu menambahkan 10.0.2.2 pada ALLOWED_HOSTS, mengaktifkan CORS dan pengaturan SameSite/cookie, dan menambahkan izin akses internet di Android? Apa yang akan terjadi jika konfigurasi tersebut tidak dilakukan dengan benar?
-> 10.0.2.2 perlu ditambahkan ke ALLOWED_HOSTS agar server Django mengenali dan menerima permintaan dari emulator Android yang menggunakan IP tersebut sebagai alias untuk mengakses localhost. Pengaturan CORS dan SameSite pada cookie dilakukan untuk mengizinkan pertukaran data lintas origin dan memastikan session cookie tetap tersimpan demi menjaga status login pengguna. Izin akses internet di AndroidManifest.xml wajib ditambahkan untuk memberikan hak bagi aplikasi Android dalam melakukan operasi jaringan ke luar perangkat. Jika salah satu konfigurasi ini terlewat, aplikasi akan mengalami kegagalan koneksi, permintaan data diblokir oleh server, atau pengguna akan terus-menerus logout karena sesi tidak tersimpan.

5. Jelaskan mekanisme pengiriman data mulai dari input hingga dapat ditampilkan pada Flutter.
-> Proses dimulai ketika pengguna memasukkan data di aplikasi Flutter yang kemudian dikemas menjadi format JSON dan dikirim ke server Django menggunakan permintaan HTTP (seperti POST). Server Django menerima permintaan tersebut, memproses data (validasi dan penyimpanan ke database), lalu mengembalikan respons berupa data JSON. Di sisi Flutter, respons JSON tersebut ditangkap, di-decode kembali menjadi objek Dart, dan digunakan untuk memperbarui state aplikasi. Akhirnya, widget Flutter akan dibangun ulang (rebuild) secara otomatis untuk menampilkan data terbaru tersebut ke layar pengguna.

6. Jelaskan mekanisme autentikasi dari login, register, hingga logout. Mulai dari input data akun pada Flutter ke Django hingga selesainya proses autentikasi oleh Django dan tampilnya menu pada Flutter.
-> Proses dimulai saat pengguna memasukkan data di Flutter yang dikirim via permintaan HTTP ke endpoint register_ajax untuk pembuatan akun atau login_ajax untuk masuk menggunakan kredensial yang ada. Di sisi server, Django memvalidasi data tersebut menggunakan UserCreationForm atau AuthenticationForm. Jika valid, Django akan membuat sesi pengguna serta mengirimkan respons berisi session cookie (sessionid). Instance CookieRequest di Flutter kemudian menangkap dan menyimpan cookie tersebut yang berfungsi sebagai "tanda pengenal" bahwa pengguna telah terautentikasi untuk setiap permintaan berikutnya. Berkat cookie yang tersimpan ini, Flutter dapat mengakses halaman yang dilindungi karena Django mengenali sesi aktif pengguna. Terakhir saat tombol logout ditekan, Flutter mengirim permintaan ke logout_user untuk menghapus sesi di server dan secara lokal membersihkan cookie, sehingga pengguna kembali ke status belum terautentikasi.

7. Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step! (bukan hanya sekadar mengikuti tutorial).
-> Implementasi dimulai di sisi Django dengan mendaftarkan konfigurasi URL aplikasi main ke dalam urls.py proyek dan mendefinisikan endpoint spesifik seperti login_ajax, register_ajax, serta logout yang dipetakan ke fungsi views terkait. Dalam proses registrasi, fungsi register_ajax memvalidasi data menggunakan UserCreationForm dan mengembalikan status sukses atau error dalam format JSON tanpa memuat ulang halaman. Serupa dengan itu, login_ajax memverifikasi kredensial pengguna menggunakan AuthenticationForm dan jika valid, membuat sesi aktif di server serta mengirimkan session cookie sebagai tanda pengenal. Di sisi klien, Flutter menggunakan instance CookieRequest yang dibagikan ke seluruh aplikasi untuk menangkap dan menyimpan cookie tersebut secara otomatis, memastikan status login pengguna tetap terjaga saat berpindah layar. Berbeda dengan permintaan HTTP standar, CookieRequest memungkinkan Flutter mengakses endpoint terproteksi di Django karena server dapat mengenali sesi yang valid dari cookie yang dikirimkan. Mekanisme routing di Flutter kemudian merespons hasil JSON dari server; misalnya, jika login berhasil, Navigator akan memindahkan tampilan ke halaman utama. Proses logout bekerja dengan memanggil fungsi logout bawaan Django untuk menghapus sesi di server, diikuti dengan pembersihan cookie di sisi klien untuk mengakhiri akses. Dengan pendekatan ini, Django berperan penuh sebagai penyedia API dan pengelola keamanan sesi, sementara Flutter fokus pada penyajian antarmuka yang responsif. Integrasi ini memastikan alur autentikasi yang aman dan pengalaman pengguna yang mulus dari pendaftaran hingga keluar aplikasi.

